---
title: "H9_RPE Dataset Integration"
output:
  html_document:
    df_print: paged
---

## Notebook setup
```{r packages}
library(Seurat)
library(tidyverse)
library(ggpubr)
library(ComplexHeatmap)
```

## Assigning clusters to analysed datasets
Set control to resolution 0.6 and aged to 0.7. These values were determined from
the clustree generated in each sample's analysis.

```{r prepData}
# Load objects
control_obj <- readRDS("/Volumes/LACIE/RPE_scRNA/PUBLISHED/H9_RPE_YOUNG_Analysed_Object.rds")
aged_obj <- readRDS("/Volumes/LACIE/RPE_scRNA/PUBLISHED/H9_RPE_AGED_Analysed_Object.rds")

# Set resolution
control_obj[["seurat_clusters"]] <- control_obj[["SCT_snn_res.0.6"]]
control_obj[["condition"]] <- "Young"
Idents(control_obj) <- "seurat_clusters"

aged_obj[["seurat_clusters"]] <- aged_obj[["SCT_snn_res.0.7"]]
aged_obj[["condition"]] <- "Aged"
Idents(aged_obj) <- "seurat_clusters"
```

### Cluster sizes
Analysis of each dataset identified 11 subpopulations. We will need to
investigate if these clusters are comparable, after integration.

```{r clusterSizes}
# Extract cluster data from Seurat objects
control_metadata <- FetchData(control_obj, vars = c("condition", "seurat_clusters"))
aged_metadata <- FetchData(aged_obj, vars = c("condition", "seurat_clusters"))

# Tabulate cluster counts
control_cluster_counts <- as.data.frame(table(control_metadata$seurat_clusters))
aged_cluster_counts <- as.data.frame(table(aged_metadata$seurat_clusters))

# Combine cluster counts
cluster_counts <- left_join(control_cluster_counts, aged_cluster_counts, by = "Var1")
colnames(cluster_counts) <- c("Cluster", "Control", "Aged")
cluster_counts
```

### Find integration anchors
We will use CCA to identify the anchors and the SCTransform integration workflow
to integrate the two datasets. Note that this method harmonizes the residuals
generated by the SCTransform normalization method for each sample, and then 
combines them into one matrix.

```{r integration_anchors}
# Edit globals because we need these for some reason
options(future.globals.maxSize = 1600 * 1024^3)
gene_list <- intersect(rownames(control_obj), rownames(aged_obj))
object_list <- list(Control = control_obj, Aged = aged_obj)
common_features <- SelectIntegrationFeatures(object.list = object_list, nfeatures = 3000)
object_list <- PrepSCTIntegration(object.list = object_list, anchor.features = common_features, verbose = FALSE)
object_anchors <- FindIntegrationAnchors(object.list = object_list, normalization.method = "SCT", anchor.features = common_features, verbose = FALSE)
seurat_obj <- IntegrateData(anchorset = object_anchors, 
                            normalization.method = "SCT",
                            verbose = FALSE)
```

### Review integrated anchors
```{r check_integration, fig.width = 6}
# Dimensionality reduction
seurat_obj <- RunPCA(seurat_obj, verbose = FALSE)
seurat_obj <- RunUMAP(seurat_obj, dims = 1:30, seed.use = 1)

# Generate UMAP plots and label by cluster and condition to ensure
# integration hasn't introduced any batch effects

plots <- DimPlot(seurat_obj, group.by = "seurat_clusters", split.by = "condition", combine = FALSE)
plots <- lapply(X = plots, FUN = function(x) x + theme(legend.position = "top") + guides(color = guide_legend(nrow = 3, 
    byrow = TRUE, override.aes = list(size = 2))))
batch_plot <- DimPlot(seurat_obj, group.by = "condition") + ggtitle("Age")
plots[[2]] <- batch_plot
CombinePlots(plots)
```

### Metaneighbor Analysis
Metaneighbor identifies closeness of clusters based on variable genes. 
Theoretically, markers from one dataset can be used to identify markers in
other datasets.

```{r metaneighbor}
library(MetaNeighbor)
library(SingleCellExperiment)

# Prepare data for conversion to SingleCellExperiment
metadata <- FetchData(seurat_obj, vars = c("orig.ident", "condition", "seurat_clusters"))
metadata$cluster <- paste0(metadata$condition, "_", metadata$seurat_clusters)
seurat_obj[["cluster"]] <- metadata$cluster
sce_obj <- as.SingleCellExperiment(seurat_obj)

# Run unsupervised metaneighbor based on top variable genes
variable_genes <- variableGenes(sce_obj, exp_labels = sce_obj$condition)
celltype_nv = MetaNeighborUS(var_genes = variable_genes,
dat = sce_obj,
study_id = sce_obj$condition,
cell_type = sce_obj$seurat_clusters, fast_version = TRUE)

```

Representing results as a heatmap of AUROC values.

```{r aurocHeatmap, fig.width = 6}
# Plot metaneighbor AUC values as a heatmap
cols = rev(colorRampPalette(RColorBrewer::brewer.pal(11,"RdYlBu"))(100))
breaks = seq(0, 1, length=101)

auroc_matrix <- celltype_nv[paste0("Aged|", as.character(0:11)), 
                            paste0("Young|", as.character(0:11))]
auroc_plot <- Heatmap(auroc_matrix, col = cols, name = "AUROC",
                      rect_gp = gpar(col = "white", lwd = 2))
draw(auroc_plot)
```

The heatmap shows we have pairs of clusters from each timepoint that have an
AUROC value of 0.8 or greater. These would be clusters that share the greatest
similarity.

```{r integrate_clusters}
# Integrate clusters
celltype_df <- as.data.frame(celltype_nv)
celltype_df$ref_cluster <- rownames(celltype_df)
celltype_df <- celltype_df %>% gather(cluster, AUROC, -ref_cluster)

# Remove equal clusters
diff_clusters <- subset(celltype_df, celltype_df$ref_cluster != celltype_df$cluster)

# Separate clusters
diff_clusters <- subset(diff_clusters, startsWith(diff_clusters$ref_cluster, "Young"))
diff_clusters <- subset(diff_clusters, startsWith(diff_clusters$cluster, "Aged"))

# Select clusters that have AUROC of 0.9
top_hits <- topHits(cell_NV = celltype_nv,
dat = sce_obj,
study_id = sce_obj$condition,
cell_type = sce_obj$seurat_clusters,
threshold = 0.9)

print(top_hits)
```

This function has identified the top 10 most similar results. We will take the
clusters that have a mean AUROC of 0.8 for integration.

```{r select_out_clusters}
top_hits <- top_hits %>% filter(Match_type == "Reciprocal_top_hit" & 
                                  Mean_AUROC > 0.8) 
top_hits <- top_hits %>% mutate(Common = 1:nrow(top_hits))
colnames(top_hits) <- c("Young", "Aged", "Mean_AUROC", "Match_type", "Common")
top_hits$Young <- gsub("^Young[|]", "", top_hits$Young)
top_hits$Aged <- gsub("^Aged[|]", "", top_hits$Aged)

print(top_hits)
```

# Generate new cluster labels
 We will assign new cluster labels for these populations, and
assign new labels to the original clusters. We will follow standard cluster
identification assignments by numbering clusters from largest to smallest.

```{r labelClusters}
# Extract metadata
metadata <- FetchData(seurat_obj, vars = c("condition", "seurat_clusters"))

# Need to tally cell counts so we can figure out which cluster is the largest,
# and then count them accordingly
countCommonClusterCells <- function(x){
  control_count <- nrow(metadata[which(metadata$condition == "Young" & metadata$seurat_clusters == x[["Young"]]), ])
  aged_count <- nrow(metadata[which(metadata$condition == "Aged" & metadata$seurat_clusters == x[["Aged"]]), ])
  return(control_count + aged_count)
}

common_cluster_counts <- apply(top_hits, 1, countCommonClusterCells)
top_hits$Counts <- common_cluster_counts
top_hits$Common <- 1:nrow(top_hits)

# Add column
metadata$cluster <- "Common_0"

# Assign clusters for each row
for (n in 1:nrow(top_hits)){
  x <- top_hits[n, ]
  control_cluster <- x$Young
  aged_cluster <- x$Aged
  new_cluster <- paste0("Common_", x$Common)

  metadata[which(metadata$condition == "Young" & metadata$seurat_clusters == control_cluster), "cluster"] <- new_cluster
  metadata[which(metadata$condition == "Aged" & metadata$seurat_clusters == aged_cluster), "cluster"] <- new_cluster
}

# If cluster == Common_0, create alternative labels
exclusive_clusters <- subset(metadata, metadata$cluster == "Common_0")

# Count clusters by condition
unique_cluster_counts <- exclusive_clusters %>% group_by(condition, seurat_clusters) %>% summarize(Counts = n())

# Preserve cluster 0
unique_cluster_counts$cluster <- NULL

# Number rows accordingly
unique_cluster_counts <- unique_cluster_counts %>% mutate(cluster = row_number() - 1)

# Create new column label
unique_cluster_counts$cluster <- paste0(unique_cluster_counts$condition, "_", unique_cluster_counts$cluster) 

for (n in 1:nrow(unique_cluster_counts)){
  x <- unique_cluster_counts[n, ]
  metadata[which(metadata$condition ==  x[["condition"]] & metadata$seurat_clusters == x[["seurat_clusters"]]), "cluster"] <- x[["cluster"]]
}

# Final cluster counts
cluster_counts <- as.data.frame(table(metadata$cluster))
colnames(cluster_counts) <- c("Cluster", "Cells")
print(cluster_counts)
seurat_obj[["cluster"]] <- metadata$cluster
Idents(seurat_obj) <- "cluster"
```

## Cluster characterisation
Characterise common clusters using the `FindConservedMarkers` function.

```{r identifyConservedMarkers, eval = FALSE}
# Find markers for each cluster
integrated_markers <- FindAllMarkers(seurat_obj, test.use = "bimod")

# Find conserved markers
conserved_markers1 <- FindConservedMarkers(seurat_obj, 
                                           ident.1 = "Common_1", 
                                           grouping.var = "condition", 
                                           verbose = FALSE)

conserved_markers2 <- FindConservedMarkers(seurat_obj, ident.1 = "Common_2", 
                                           grouping.var = "condition", 
                                           verbose = FALSE)

conserved_markers3 <- FindConservedMarkers(seurat_obj, 
                                           ident.1 = "Common_3", 
                                           grouping.var = "condition", 
                                           verbose = FALSE)

conserved_markers4 <- FindConservedMarkers(seurat_obj, 
                                           ident.1 = "Common_4", 
                                           grouping.var = "condition", 
                                           verbose = FALSE)

conserved_markers5 <- FindConservedMarkers(seurat_obj, 
                                           ident.1 = "Common_5", 
                                           grouping.var = "condition", 
                                           verbose = FALSE)

conserved_markers6 <- FindConservedMarkers(seurat_obj, 
                                           ident.1 = "Common_6", 
                                           grouping.var = "condition", 
                                           verbose = FALSE)

# Find differentially expressed genes between age within clusters
for (cluster in as.character(1:6)){
  cluster_id <- paste0("Common_", cluster)
  condition_de_results <- FindMarkers(seurat_obj, ident.1 = "Aged", 
                              ident.2 = "Young", 
                              group.by = "condition", 
                              subset.ident = cluster_id,
                              test.use = "bimod")
  condition_de_results <- condition_de_results %>% rownames_to_column("gene_id")
}

```
